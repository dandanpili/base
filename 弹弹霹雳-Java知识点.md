[TOC]

# 一、Java基础

## 1.1 String、StringBuffer、StringBuilder的区别是什么？

### 可变性

String类中使用final关键字修饰字符数组来保存字符串，所以String对象是不可变的。

```java
pirvate final char value[];

//在Java9之后，String类的实现改用byte数组存储字符串
private final byte[] value;
```

StringBuilder与StringBuffer都继承AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串`char[] value`，但是没有用final关键字修饰，所以这两种对象都是可变的

### 线程安全性

String中的对象是不可变的，也就可以理解为常量，线程安全。

StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

StringBuilder并没有对方法进行加同步锁，所以是非线程安全的

### 性能

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。

StringBuilder和StringBuffer每次都会对对象本身进行操作，而不是生成新的对象。

StringBuilder的性能比StringBuffer的性能要好，但是会冒多线程不安全的风险

###  使用总结

1. 操作少量的数据：适用String
2. 单线程操作字符串并操作大量数据：适用StringBuilder
3. 多线程操作字符串并操作大量数据：使用StringBuffer

# 二、操作系统

## 2.1 进程和线程的区别？

1. 一个进程可以有多个线程
2. 线程是进程划分的更小的运行单位，一个进程在其执行过程中可以产生多个线程
3. 各进程基本上是独立的，而线程则不一定，同一进程中的线程极有可能会互相影响
4. 线程执行开销小，但是不利于资源的管理和保护，而进程正相反

# 三、MySQL

## 3.1 SQL注入的原理、预防？

### 原理

主要原因是对用户输入的绝对信任，相信用户所有的输入都是可信的，没有对用户输入的语句进行过滤或者筛选，直接放到sql语句中进行拼接，从而导致了sql注入的产生

### 预防

sql注入的本质是对用户输入的绝对信任，当我们对用户输入的数据不绝对信任的时候，就可以预防sql注入

1. 输入数据长度的限制
2. 关键字过滤：对每个参数的传递进行检测，对sql关键字如`select`、`insert`、`where`等，进行过滤，可以采用**正则**和**递归**过滤
3. 对参数携带的特殊字符进行转义和过滤：大部分注入点都是在字符位置发生的，所以对每个参数进行闭合符号判断，如果参数携带的单引号没有闭合，会导致sql中一部分数据被视为字符串
4. 预编译防注入：在数据库对sql语句进行预编译之后，sql语句已经被数据库编译和优化了，并且运行数据库以参数化的形式进行查询，即使传递敏感字符也不会被执行，而是被当做参数处理

如果发生了sql注入，不要直接显示出错误原因，最好指定一个错误页面，尤其是sql注入（让他们去盲注）